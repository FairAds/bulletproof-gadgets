# Android interface

This library exposes two methods that allow our Android Java example app to use the prove / verify mechanics from the core code base.

## Compilation instructions

 - Make sure the Android NDK is installed. Generate the architecture toolchains.
 - Link the toolchains to your Rust installation via your Cargo config file. Create a file `~/.cargo/config` if it doesn't exist, and place the following into it:
```toml
[target.aarch64-linux-android]
ar = "/PATH/TO/ANDROID/NDK/TOOLCHAIN/arm64/bin/aarch64-linux-android-ar"
linker = "/PATH/TO/ANDROID/NDK/TOOLCHAIN/arm64/bin/aarch64-linux-android-clang"

[target.armv7-linux-androideabi]
ar = "/PATH/TO/ANDROID/NDK/TOOLCHAIN/arm/bin/arm-linux-androideabi-ar"
linker = "/PATH/TO/ANDROID/NDK/TOOLCHAIN/arm/bin/arm-linux-androideabi-clang"

[target.i686-linux-android]
ar = "/PATH/TO/ANDROID/NDK/TOOLCHAIN/x86/bin/i686-linux-android-ar"
linker = "/PATH/TO/ANDROID/NDK/TOOLCHAIN/x86/bin/i686-linux-android-clang"
```
 - Add the target architectures to `rustup` to enable cross compilation.

```
rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android
```

 - Compile the library

```
./build.sh
```

- And done! Take note of the location of the compiled `.so` files, you'll need them on the Android side.

## Further development

The only thing to note in order to use this code is that you need to build the Android part first. That determines the name of the exposed functions, and how they interact with your app. For instance, for this example, we used the following Java data structure (`com.unholster.examplebulletproofs.BulletproofWrapper`):

```java
class BulletproofWrapper {
    String name;
    String instance;
    String witness;
    String gadgets;
    String commitments;
    byte[] proof;

    // constructors

    // autogenerated getters and setters

}
```

After building and locating the `.class` files, we ran `javap -s` on the corresponding class file to get the JNI signatures we needed (example in the comments in `lib.rs`):

```
javap -s /PATH/TO/BUILD/FOLDER/intermediates/javac/debug/classes/com/unholster/examplebulletproofs/BulletproofWrapper.class
```

You need the JNI signatures before you can use `JNIEnv.call_method`.

Your function name will also depend on your Java code. We used this class:

```java
public class RustBulletproofs {
    private static native void extProve(final BulletproofWrapper data);
    private static native boolean extVerify(final BulletproofWrapper data);

    public static HashMap<String, Object> prove (String name, String instance, String witness, String gadgets) {
        // call extProve with java objects
    }

    public static boolean verify (String name, String instance, String gadgets, String commitments, byte[] proof) {
        // call extVerify with java objects
    }
}
```

The name of a JNI-compatible Rust function must be `Java_<domain>_<classname>_<methodname>`, therefore we had to use `Java_com_unholster_examplebulletproofs_RustBulletproofs_extProve` and `Java_com_unholster_examplebulletproofs_RustBulletproofs_extVerify`.